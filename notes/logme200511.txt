*2005/11/07 13:33:23 串口驱动程序没法通知应用发送了多少数据

感觉windows 自带的传真软件和winfax都不管驱动返回的writenlen这个字段的
值，总是认为全部都发送出去了。int main() { char buf[MAX_LEN+1];
unsigned long ms; COMMTIMEOUTS timeouts; unsigned long event; HANDLE
fd = CreateFile("\\\\.\\COM4", GENERIC_READ | GENERIC_WRITE, 0, NULL,
OPEN_EXISTING, NULL, NULL);

    HANDLE fd = CreateFile("\\\\.\\COM4", GENERIC_READ |
			   GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
			   NULL, NULL);
    if(fd==NULL)
    {
	exit(0);
    }	
    memset(longbuf, 0x0F, 6000);
    WriteFile(fd, longbuf, 6000, &writelen, NULL);
    printf("writen %d\r\n", writelen);
    return;

是否在WriteFile的返回值里也需要做一些特殊的处理呢？是否应该用
ERROR_PARTIAL_COPY作为返回值呢？

http://support.microsoft.com/default.aspx?scid=kb;en-us;113996
这个地方把驱动程序里的STATUS_XXXX_XXXX对应到应用里的ERROR_XXXX。
STATUS_PARTIAL_COPY对应ERROR_PARTIAL_COPY。

下一步就看看windows自己的serial驱动里有没有返回STATUS_PARTIAL_COPY。

*2005/11/07 13:48:06 今天又更新了一下dotemacs

当初一直在找合适的blog提供商，可以方便的搜索的，今天忽然发现用emacs的
outline-minor-mode编辑一些文本文件就可以实现这个功能，再加上fill，效果
简直太好了！

*2005/11/08 10:28:22 Eclipse As Emacs

蓦然回首，Eclipse里面已经支持了一些基本的Emacs Key Bindings。

*2005/11/09 13:49:28 vmware!

今天装了个vmware在机器上，还装了个debian，却没法让debian访问apt源，气
死我了！我只是想试试网上的USB网卡驱动能不能驱动我的DWL-120+。今天早上
我把网卡拆开来，才确定芯片是TNETW1100B，也就是传说中的ACX100。
总不会让我把debian的那几张光盘都下载下来吧！？

*2005/11/10 09:29:13 Red Black Tree

这个是我准备在Data Structures and Algorithms这本书里看的最后一个部分啦！
虽然后面还有一些内容，但是已经一个月过去了，我不能老看这一本书呀。

*2005/11/10 10:25:03 FAX

**实验1
接收方用3618，发送用btp。两边都监视modem，看发送的数据是否都被接收到。
事实是不能。
**实验2
监视发送方的串口驱动。
结论是数据有问题。举例：
1 假设send.txt第1099行对应rec.txt第1124行，send.txt第1117行对应rec.txt
第1129行。(这个对应关系是基于对应行以及后面的一行以上数据相同，并且文件
里没有其他匹配的行组。)则send.txt的1102到1116，接收方得到的是1127和
1128两行，无论长度或者数值都不对。
2 假设send.txt的1096以及前面三行，对应rec.txt的1089以及前面三行，
send.txt的1099以及后面两行，对应rec.txt的1124以及后面两行。则rec.txt的
1090到1123行，凭空比发送的多出了数据。
3 另外1031到1035看来只是采样出了一些问题。

上述的数据都是在启动了硬件流控的基础上得到的。
上述数据文件都已经保存为r1.txt，rr1.txt，s1.txt。
**实验3
重复实验2。这次的效果比较好。几乎没有传错的，只是有些地方的数据被收为
0xFF了。另外最后多出来一些字节，不知道是怎么回事。ss2, s2, r2, rr2
**实验4
重复实验2。还是有数据变成FF的情况，另外，结尾前还是收到一些莫名其妙的
数。实验的文件为rr4.txt, ss4.txt, r4.txt, s4.txt。
**实验5
重复实验2。文件为rr3.txt, ss3.txt, s3.txt, r3.txt。
30500前面丢了一些数，后面就开始乱了。

明天实验一下那几个初始化指令。

*2005/11/11 08:44:00 实验带初始化命令的FAX

ATV1设置modem的回应为OK方式而不是0方式。
ATS0设置modem自动应答功能，ATS0=0为关。
ATS8设置comma dial modifier的等待秒数，不懂什么意思。

*2005/11/11 09:51:49 Multi-language of Emacs

All supported charater sets are supported in Emacs buffers whenever
multibyte characters are enabled; there is no need to select a
particular language in order to display its characters in an Emacs.
一针见血，告诉你显示多字节文字，你什么也不用做。

However, it is important to select a language environment in order to
set various defaults. The language environment really represents a
choice of preferd script (more or less) rather than a choice of
language.
但是选择语言环境还是很重要的，不过这个选择主要在于选择喜好的脚本而非选
择语言了。

language environment控制读取文件时候用什么coding system去识别。设置变
量current-language-environment或者用M-x set-language-environment可以设
置language environment。设置是全局的。

为了显示language environment支持的字符，需要一个合适的font。开始的时候，
Emacs先看系统的LC_ALL, LC_CTYPE, LANG等设置，看是否可以找到
locale-charset-language-names或者 locale-language-names表里对应的项目。
前者会覆盖后者。

set-locale-environment用language environment的 coding system去解码系统
消息。

coding systems。Emacs用不同的 coding system 解码文件的内容。它会自动的
搜寻支持的所有 coding systems，找可以正确解码文件的 coding system，搜
寻依照的优先级是根据 language environment 确定的。可以用 M-x
prefer-coding-system 改变优先级。用 modify-coding-system-alist 也可以
根据文件名来确定 coding system。

一个长字体名字是如下格式的：

     -MAKER-FAMILY-WEIGHT-SLANT-WIDTHTYPE-STYLE...
     ...-PIXELS-HEIGHT-HORIZ-VERT-SPACING-WIDTH-REGISTRY-ENCODING

PIXELS 是一个数字，表示一个字符占几个 pixel 高

HIGHER 是一个数字，表示一个字符在打印机中的 point 乘以10的数值，打印机
的 point 大约是 1/720 个 inch。在固定的分辨率下，PIXELS 和 HIGHER 是成
比例的，所以一般就填一个，另一个填*就是了。

HORIZ 是一个数字，表示水平分辨率。
VERT表示垂直分辨率。
这两个数值一般填*，因为系统里的字体分辨率会设置为适合你的显示器。

SPACEINC m(monospace) p(proportional) c(characters cell)

WIDTH 字符平均 pixel 宽度乘以 10。

emacs22 有个问题，中文不能 fill。

*2005/11/11 15:08:26 继续实验FAX吧！

发现问题了。windows2k 自动发送了一个 AT\Q1 给模块，不知道是否覆盖了
AT\Q3 （硬件流控）的设置。已经给 Siemens 工程师发信。

*2005/11/14 09:12:51 看来驱动程序不得不改了

Siemens 陈明一大早打电话来，告知AT\Q1会覆盖AT\Q3，唉。那如果用 win2k 发传真，
用 winfax 是必不可少了。我先用 winxp 试试是否winxp 不发 AT\Q1 吧。

给 TryWrite 加上了一些东西，发送中还是有少量丢数据的情况，很奇怪。先测
试一下边界条件吧。

不用该驱动了，只要把 Parameters.Write.Length 大于 4096 的部分去掉就可
以了。早知道看看DDK里的代码好了。

发送和接收的数据差不多了，不过到最后还是接收到了一些没有用的数据。存成
了 recv.txt 和 send.txt。PC发送的东西和手机传给串口的一致了。

*2005/11/15 09:02:46 马上出BETA2.0了

BETA2.0要改完现在所有的bug，这几乎是不可能完成的。

今天我要在驱动里打印一下发送的数据和实际发出去的数据是否一样。

我需要一个真正的串口无线模块看看它发出去的东西是什么样子的。设置模块波
特率 AT+IPL=。

终于可以差不多了。PC驱动每次发送4096字节，超过的部分需要在下一次发。下
面的任务是测试边界条件了。

*2005/11/15 14:56:33 zyzzyva

一个单词，也许是字典最后一个。意思是  Any of various tropical American
weevils of the genus Zyzzyva, often destructive to plants.

*2005/11/15 16:51:38 停电了

手机断电后，PC的反应有点问题。也许手机断电或者拔掉后，应该马上用错误状
态完成irp。明天再试吧。

*2005/11/16 16:30:52 数据结构和算法暂时结束

也许我应该给自己找个测验题来做做。Red Black Tree 太繁琐了没有看完。留
到以后有心情吧。好了，开始停电的测试吧。

*2005/11/16 17:01:20 停电了正式开始

usb拔线或者断电都返回0xC000009C，宏是 STATUS_DEVICE_DATA_ERROR。

还有一个问题，关闭串口的时候是否需要清除所有读到的数据？

先改读看看有什么反应吧。确实不会造成超级终端死机了。

再改写。tag是benefon_4，完成。

*2005/11/17 09:43:15 Outlook and Emacs

昨天偶然看到说可以用 Emacs 作为 Outlook 的编辑器。今天来下载了一下，保
存在 e:/emacs-el 里面的 Outlook 和 PyMac 了。作者说了一句话，让我放弃
了用这个东西：Not sure if it is really more efficient than using the
clipboard :-)

*2005/11/17 09:47:24 TRAMP

TRAMP 的问题是不能在远程的系统上运行 grep 之类的东西，只能简单的打开文
件什么的。用法：
C-x C-f /ip.ip.ip.ip:/path/to/filename
C-x C-f /su::/path/to/filename

*2005/11/17 14:40:37 必备vim plugin: taglist

最基本的功能：Tlist，列出当前的entry。
每次打开新的文件都在 Tlist 窗口里添加一些新的 entry。

又找到一个 bufexplorer。不过不大会用。

*2005/11/17 17:19:32 linux on going

CONFIG_MTD_BULVERDE 在 config 里选择为y了。编译 bulverde.c 这个文件。
这个文件里定义了 mtd 设备的情况，filesystem 用 partition 2，从
0x00240000 开始，而在config 里定义了 
CONFIG_CMDLINE="root=/dev/mtdblock2 console=ttyS1,115200 mem=32M"。这
样系统就需要一个文件系统在 flash 的 0x00240000 位置，大小是 0x01800000。

Bummer, can't open /dev/tty1，这个东西以前解决过，真是郁闷呀。

*2005/11/18 09:56:24 Bummer, can't open /dev/tty1

在哪里打开 /dev/tty1，为什么要打开 /dev/tty1？我的串口线有问题，不能往
串口里写东西。

*2005/11/18 10:03:59 ROME

http://wiki.java.net/bin/view/Javawsxml/Rome04HowRomeWorks 这里有一篇
讲 How ROME Works 的文章。

** My code calls SyndFeedInput to parse a Newsfeed.

** SyndFeedInput delegates to WireFeedInput to do the actual parsing.

** WireFeedInput uses a PluginManager of class FeedParsers to pick the
   right parser to use to parse the feed and then calls that parser to
   parse the Newsfeed.

** The appropriate parser parses the Newsfeed parses, using JDom, into
   a WireFeed. If the Newsfeed is in a RSS format, then the WireFeed
   is of class Channel and contains items, Clouds, and other RSS
   things from the com.sun.syndication.feed.rss package. Or, on the
   other hand, if the Newsfeed is in Atom format, then the WireFeed is
   of class Feed from the com.sun.syndication.atom package. In the
   end, WireFeedInput returns a WireFeed.

** SyndFeedInput uses the returned WireFeedInput to create a
   SyndFeedImpl. Which implement SyndFeed. SyndFeed is an interface,
   the root of an abstraction that represent a format independant
   Newsfeed.

** SyndFeedImpl uses a Converter to convert between the format
   specific WireFeed representation and a format-independent SyndFeed.

** SyndFeedInput returns to you a SyndFeed containing the parsed
   Newsfeed.

** SyndFeedInput input = new SyndFeedInput();
   SyndFeed feed = input.build(new XmlReader(feedUrl));

** Rome represents syncdication feeds (RSS and Atom) as instances of the
   com.sun.syndication.synd.SyndFeed interface.

*2005/11/18 13:26:23 Adding one more virtual USB port

*2005/11/18 15:42:43 What is JavaBean?

The JavaBeans API makes it possible to write component software in the
Java programming language. Components are self-contained, reusable
software units that can be visually composed into composite
components, applets, applications, and servlets using visual
application builder tools.

还是当年的 Delphi 控件，呵呵。

*2005/11/18 17:46:06 串口驱动

Uncompressing Linux 的时候，用
include/asm-arm/arch-pxa/uncompress.h/putc 直接放到 UART。

*2005/11/20 16:27:36 thread models

邮件列表里有人找人做作业，说要找如下 thread models:

** Boss-worker(s) or Delegation model. A central thread(boss) creates
   the threads(workers), assigning each worker a task. Each worker is
   assigned a task by the boss thread. The boss thread may wait until
   each thread completes that task. Examples: Web server,

** Peer-to-Peer. All the threads have a equal working status. Threads
   are called peer threads. A peer thread creates all the threads
   needed to perform the tasks but performs no delegation
   responsibilities. The peer threads can process requests from a
   single input stream shared by all the threads or each thread may
   have its own input stream. 

** Pipeline. An assembly-line approach to processing a stream of input
   in stages. Each stage is a thread that performs work on a unit of
   input. When the unit of input has been through all the stages, then
   the processing of the input been completed.

** Producer-Consumer Examples: A producer thread produces data to be
   consumed by the consumer thread. The data is stored in a block of
   memory shared by the producer and consumer threads. Examples: Media
   player with GUI,

*2005/11/20 21:09:19 What is JDOM

What is DOM firstly: The Document Object Model is the second major
standard API for XML parsers. DOM programs start off similarly to SAX
programs, by having a parser object read an XML document from an input
stream or other source. However, where the SAX parser returns the
document broken up into a series of small pieces, the equivalent DOM
method returns an entire Document object that contains everything in
the original XML document.

JDOM is a more javaish DOM.

*2005/11/21 09:30:39 Visual Bell

控制台调节音调：echo -e"\\33[10;50]\\33[11;100]"
50 means the bell frequency in Hertz.
100 means the bell duration in milli-seconds.
33 is ASCII ESC.

*2005/11/21 14:49:17 MySQL installation

Copy MySQL configuration file my-medium.ini to SYSTEMROOT directory.
Rename it to my.ini.
Edit my.ini:
Under Sections [client] and [mysql], edit:
	socket = c:/tmp/mysql.lock
Under Section [mysql], insert:
	basedir = c:/mysql
	datadir = c:/mysql/data

To start the server, enter this command:
C:\>C:\mysql\bin\mysql --console

To stop the server:
C:\>C:\mysql\bin\mysqladadmin.exe -u root shutdown

To test:
C:\>C:\mysql\bin\mysqlshow.exe -u root
C:\>C:\mysql\bin\mysqladmin.exe version status proc -u root
C:\>C:\mysql\bin\mysqlshow.exe test -u root

http://stardeveloper.com/articles/display.html?article=2003090201&page=2 
这里讲到，用 InnoDB Tables 可以支持 transaction。

命令 use：转换数据库

http://stardeveloper.com/articles/display.html?article=2003090201&page=4
这里讲到把 JDBC driver 的那个JAR文件拷贝到Java根下的lib/ext目录，再加
一个环境变量 CLASS_PATH 就可以了。

*2005/11/21 20:54:43 编译Emacs22

http://learn.tsinghua.edu.cn/homepage/2004211031
/publish/GNU/compile_emacs.html
这里给出了编译Emacs22的方法。我看了半天，忽然发现，当初我编译Emacs21.4
是因为没有编译好的版本，现在有编译好的，我干吗要自己编呀，把这哥们的22
和23都下一份算了。拿来主义，更省事。

其中Emacs23的GBK扩展汉字显示有问题，加入如下的配置在.emacs里就好了：
(setq font-encoding-alist 
     (cons '("gb2312.1980" . chinese-gbk) font-encoding-alist))

(create-fontset-from-fontset-spec
  "-*-Courier New-normal-r-*-*-16-*-*-*-c-*-fontset-chinese,
  chinese-gb2312:-outline-宋体-normal-r-normal-normal-*-*-96-96-p-*-gb2312.1980-0" t)

(setq default-frame-alist
    (append
    '((font . "fontset-chinese"))
     default-frame-alist))

*2005/11/21 22:04:32 SQL

想不到我又重新开始学SQL了，当年觉得SQL绝对是低智商的人玩的东西。

SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy;

what_to_select refer to columns.
in conditions_to_satisfy REGEXP means working as regular expression.

*2005/11/21 22:33:27 ROME Test

main函数在 TestOpsRSS091N.java, TestOpsRSS094.java, TestXmlReader.java
这几个文件里有。

现在 JDOM 还不知道如何能让我的工程用到。

两个工程联系起来的方法：
Project->Properties->Java Build Path->Project->Add->Project You Want
Import

复用（生成 JAR 文件）：
File->Export->JAR
JAR 其实就是一种压缩文件。

用外部的 JAR 文件：
Window->Preference->Java->Build Path->Classpath
Add a new path variable to your JAR file. 
Project->Properties->Java Build Path->Libraries->Add Variable

我看直接用 Add External JAR 好像也可以。

http://www.cs.laurentian.ca/badams/c1047/eclipse-tutorials/
这里给了一个简明带图的 eclipse 导航。

*2005/11/22 09:32:25 flip_write 写jffs2全零

我觉得是 filp_write 后没有用 flush，就 close 了，使得数据没有写到flash 
上。还需要验证。不，肯定不是，因为 filp_close 里带了 flush。

core dump 在我们的系统里不好由内核来做，应该再搞一个进程来监视，内核把
数据给这个进程来创建 core 文件。

EFAULT 是从 __copy_from_user 返回的。

__copy_from_user:
r0: to
r1: from
r2: length

		stmfd	sp!, {r0, r2, r4 - r7, lr}

保存 r0, r2, r4-r7, lr(r14)
偏移量r14->0, r7->4, r4->16, r2->20, r0->24

		cmp	r2, #4
		blt	.cfu_not_enough

r2小于4，则跳到 .cfu_not_enough

		ands	ip, r0, #3
		bne	.cfu_dest_not_aligned

to地址没有对齐，跳到 .cfu_dest_not_aligned

.cfu_dest_aligned:
		ands	ip, r1, #3
		bne	.cfu_src_not_aligned

from地址没有对齐，跳到 .cfu_src_not_aligned
否则开始下面的大规模4字节对齐的拷贝

.cfu_0fupi:	subs	r2, r2, #4
		addmi	ip, r2, #4
		bmi	.cfu_0nowords

length 减4，得数为负数则跳到 .cfu_0nowords，这看起来是个循环的条件判断

abort_23:	ldrt	r3, [r1], #4
		str	r3, [r0], #4
		mov	ip, r1, lsl #32 - PAGE_SHIFT
		rsb	ip, ip, #0
		movs	ip, ip, lsr #32 - PAGE_SHIFT
		beq	.cfu_0fupi

在 user 状态下读一个数 ldrt r3, [r1], #4，保存到内核地址
左移 r1 到 ip(r12)，ip=0-ip，再右移，这是干什么？
如果得数为零，表示到了页边界吧？就跳到 .cfu_0fupi
不为零，就用接着往下走。

		cmp	r2, ip
		movlt	ip, r2
		sub	r2, r2, ip
		subs	ip, ip, #32
		blt	.cfu_0rem8lp

比较剩下的 length 和 ip，取两个里面小的，也就是说尽量多的靠近页边界，
放在 ip。减去32，如果不够，就跳到 .cfu_0rem8lp

我肯定是搞错了，从这以后所有的标签都变成了 c2u 开头的，cfu 是
copy_from_user 的意思，c2u 表示copy_to_user，真是的，没有一个字母是多
余的！

.c2u_0cpy8lp:	ldmia	r1!, {r3 - r6}

		stmia	r0!, {r3 - r6}
		ldmia	r1!, {r3 - r6}
		stmia	r0!, {r3 - r6}
		subs	ip, ip, #32
		bpl	.c2u_0cpy8lp

拷贝32个字节，如果还剩下多于32的，那一直拷贝下去。否则继续。注意到这里
的 stmia 并没有用 t 标志，这说明什么呢？

.c2u_0rem8lp:	cmn	ip, #16
		ldmgeia	r1!, {r3 - r6}
		stmgeia	r0!, {r3 - r6}
		tst	ip, #8
		ldmneia	r1!, {r3 - r4}
		stmneia	r0!, {r3 - r4}
		tst	ip, #4
		ldrne	r3, [r1], #4
		strnet	r3, [r0], #4
		ands	ip, ip, #3
		beq	.c2u_0fupi

如果不够，或者一开始就不够的话，直接跳到这里了。注意 rem 就是 remain
的简写。下面我会写 cmn 的伪代码：

alu_out = Rn + shifter_operand
N flag = alu_out[31]
Z flag = if alu_out == 0 then 1 else 0
C flag = CarryFrom(Rn + shifter_operand)
V flag = OverflowFrom(Rn + shifter_operand)

而 cmp 的伪代码是：
alu_out = Rn - shifter_operand
N flag = alu_out[31]
Z flag = if alu_out == 0 then 1 else 0
C flag = NOT BorrowFrom(Rn - shifter_operand)
V flag = OverflowFrom(Rn - shifter_operand)

注意 ip 现在是负数，所以用 cmn 和16比较。这时候 ip 高位是1，如果 ip 的
绝对值大于16，则N为1，因为16不能填满 ip 到0的窟窿。这时候就可以一次再
保存16个字节了。

然后再和8字节比较。大于8的话再拷贝八个字节。然后和4比。把4字节对齐的部
分都拷贝完了以后，让 ip 和3与，得到零头，如果是零，就跳到 .c2u_0fupi去。
其实就是跳到了这个循环的开头，那时候我说好像开始了一个循环来者，还记得
么。

注意和8比较的时候用的是 tst，伪代码是：
alu_out = Rn AND shifter_operand
N flag = alu_out[31]
Z flag = if alu_out == 0 then 1 else 0
C flag = shifter_carry_out
V flag = unaffected

.c2u_0nowords:	teq	ip, #0
		beq	.c2u_finished
.c2u_nowords:	cmp	ip, #2
		ldrb	r3, [r1], #1
abort_05:	strbt	r3, [r0], #1
		ldrgeb	r3, [r1], #1
abort_06:	strgebt	r3, [r0], #1
		ldrgtb	r3, [r1], #1
abort_07:	strgtbt	r3, [r0], #1
		b	.c2u_finished

自此跳出了4字节对齐的复制阶段。这里又判断了一下 ip 是否为零，如果是就
立刻跳到 .c2u_finished，这个标签可以依照名字看出来是完事了。后面进入了 
.c2u_nowords 的处理，前面提到过，如果要拷贝的内容长度少于4个字节，直接
到 .c2u_nowords 这个地方。

.c2u_dest_not_aligned:
		rsb	ip, ip, #4
		cmp	ip, #2
		ldrb	r3, [r1], #1
abort_01:	strbt	r3, [r0], #1
		ldrgeb	r3, [r1], #1
abort_02:	strgebt	r3, [r0], #1
		ldrgtb	r3, [r1], #1
abort_03:	strgtbt	r3, [r0], #1
		sub	r2, r2, ip
		b	.c2u_dest_aligned

这里面有点奇怪呀，前面都是 ldr 用 t 标志，这里反倒是 str 用了 t 标志。
这里还用了 abort_01 等等的标志，不知道是什么意思。总之最后跳到 
.c2u_dest_aligned 这个标签的位置。

知道了 abort_xx 是什么意思，确实是会出发异常，异常后，走到
do_page_fault 这个函数的第二个 if ，则直接返回到 abort_xx 对应的
exit_xx 了。

.c2u_not_enough:
		movs	ip, r2
		bne	.c2u_nowords
.c2u_finished:	mov	r0, #0
		ldmfd	sp!, {r2, r4 - r7, pc}

.c2u_src_not_aligned:
		bic	r1, r1, #3
		ldr	r7, [r1], #4
		cmp	ip, #2
		bgt	.c2u_3fupi
		beq	.c2u_2fupi

还是看这里的 .c2u_src_not_aligned 吧，这个地方是从循环前面跳转过来的。
先在原来的 r1 上去掉后面两位，再从偏移量加4的地方加载四个字节到 r7。ip
里保存的则是被去掉的部分，让这部分和 2 比较，大的话就跳转到 .c2u_3fupi，
复制三个字节，等于的话就跳转到 .c2u_2fupi 复制两个字节，都不是就是小于
了，那就只可能是1否则就不会到不对齐这个地方了。

.c2u_1fupi:	subs	r2, r2, #4
		addmi	ip, r2, #4
		bmi	.c2u_1nowords
		mov	r3, r7, lsr #8
		ldr	r7, [r1], #4
		orr	r3, r3, r7, lsl #24

如果要拷贝的不到四个字节，直接到 .c2u_1nowords 去。

abort_08:	strt	r3, [r0], #4
		mov	ip, r0, lsl #32 - PAGE_SHIFT
		rsb	ip, ip, #0
		movs	ip, ip, lsr #32 - PAGE_SHIFT
		beq	.c2u_1fupi
		cmp	r2, ip
		movlt	ip, r2
		sub	r2, r2, ip
		subs	ip, ip, #16
		blt	.c2u_1rem8lp

.c2u_1cpy8lp:	mov	r3, r7, lsr #8
		ldmia	r1!, {r4 - r7}
		orr	r3, r3, r4, lsl #24
		mov	r4, r4, lsr #8
		orr	r4, r4, r5, lsl #24
		mov	r5, r5, lsr #8
		orr	r5, r5, r6, lsl #24
		mov	r6, r6, lsr #8
		orr	r6, r6, r7, lsl #24
		stmia	r0!, {r3 - r6}			@ Shouldnt fault
		subs	ip, ip, #16
		bpl	.c2u_1cpy8lp
.c2u_1rem8lp:	tst	ip, #8
		movne	r3, r7, lsr #8
		ldmneia	r1!, {r4, r7}
		orrne	r3, r3, r4, lsl #24
		movne	r4, r4, lsr #8
		orrne	r4, r4, r7, lsl #24
		stmneia	r0!, {r3 - r4}			@ Shouldnt fault
		tst	ip, #4
		movne	r3, r7, lsr #8
		ldrne	r7, [r1], #4
		orrne	r3, r3, r7, lsl #24
		strnet	r3, [r0], #4			@ Shouldnt fault
		ands	ip, ip, #3
		beq	.c2u_1fupi
.c2u_1nowords:	mov	r3, r7, lsr #8
		teq	ip, #0
		beq	.c2u_finished
		cmp	ip, #2
abort_09:	strbt	r3, [r0], #1
		movge	r3, r3, lsr #8
abort_10:	strgebt	r3, [r0], #1
		movgt	r3, r3, lsr #8
abort_11:	strgtbt	r3, [r0], #1
		b	.c2u_finished

.c2u_2fupi:	subs	r2, r2, #4
		addmi	ip, r2, #4
		bmi	.c2u_2nowords
		mov	r3, r7, lsr #16
		ldr	r7, [r1], #4
		orr	r3, r3, r7, lsl #16
abort_12:	strt	r3, [r0], #4
		mov	ip, r0, lsl #32 - PAGE_SHIFT
		rsb	ip, ip, #0
		movs	ip, ip, lsr #32 - PAGE_SHIFT
		beq	.c2u_2fupi
		cmp	r2, ip
		movlt	ip, r2
		sub	r2, r2, ip
		subs	ip, ip, #16
		blt	.c2u_2rem8lp

.c2u_2cpy8lp:	mov	r3, r7, lsr #16
		ldmia	r1!, {r4 - r7}
		orr	r3, r3, r4, lsl #16
		mov	r4, r4, lsr #16
		orr	r4, r4, r5, lsl #16
		mov	r5, r5, lsr #16
		orr	r5, r5, r6, lsl #16
		mov	r6, r6, lsr #16
		orr	r6, r6, r7, lsl #16
		stmia	r0!, {r3 - r6}			@ Shouldnt fault
		subs	ip, ip, #16
		bpl	.c2u_2cpy8lp
.c2u_2rem8lp:	tst	ip, #8
		movne	r3, r7, lsr #16
		ldmneia	r1!, {r4, r7}
		orrne	r3, r3, r4, lsl #16
		movne	r4, r4, lsr #16
		orrne	r4, r4, r7, lsl #16
		stmneia	r0!, {r3 - r4}			@ Shouldnt fault
		tst	ip, #4
		movne	r3, r7, lsr #16
		ldrne	r7, [r1], #4
		orrne	r3, r3, r7, lsl #16
		strnet	r3, [r0], #4			@ Shouldnt fault
		ands	ip, ip, #3
		beq	.c2u_2fupi
.c2u_2nowords:	mov	r3, r7, lsr #16
		teq	ip, #0
		beq	.c2u_finished
		cmp	ip, #2
abort_13:	strbt	r3, [r0], #1
		movge	r3, r3, lsr #8
abort_14:	strgebt	r3, [r0], #1
		ldrgtb	r3, [r1], #0
abort_15:	strgtbt	r3, [r0], #1
		b	.c2u_finished

.c2u_3fupi:	subs	r2, r2, #4
		addmi	ip, r2, #4
		bmi	.c2u_3nowords
		mov	r3, r7, lsr #24
		ldr	r7, [r1], #4
		orr	r3, r3, r7, lsl #8
abort_16:	strt	r3, [r0], #4
		mov	ip, r0, lsl #32 - PAGE_SHIFT
		rsb	ip, ip, #0
		movs	ip, ip, lsr #32 - PAGE_SHIFT
		beq	.c2u_3fupi
		cmp	r2, ip
		movlt	ip, r2
		sub	r2, r2, ip
		subs	ip, ip, #16
		blt	.c2u_3rem8lp

.c2u_3cpy8lp:	mov	r3, r7, lsr #24
		ldmia	r1!, {r4 - r7}
		orr	r3, r3, r4, lsl #8
		mov	r4, r4, lsr #24
		orr	r4, r4, r5, lsl #8
		mov	r5, r5, lsr #24
		orr	r5, r5, r6, lsl #8
		mov	r6, r6, lsr #24
		orr	r6, r6, r7, lsl #8
		stmia	r0!, {r3 - r6}			@ Shouldnt fault
		subs	ip, ip, #16
		bpl	.c2u_3cpy8lp
.c2u_3rem8lp:	tst	ip, #8
		movne	r3, r7, lsr #24
		ldmneia	r1!, {r4, r7}
		orrne	r3, r3, r4, lsl #8
		movne	r4, r4, lsr #24
		orrne	r4, r4, r7, lsl #8
		stmneia	r0!, {r3 - r4}			@ Shouldnt fault
		tst	ip, #4
		movne	r3, r7, lsr #24
		ldrne	r7, [r1], #4
		orrne	r3, r3, r7, lsl #8
		strnet	r3, [r0], #4			@ Shouldnt fault
		ands	ip, ip, #3
		beq	.c2u_3fupi
.c2u_3nowords:	mov	r3, r7, lsr #24
		teq	ip, #0
		beq	.c2u_finished
		cmp	ip, #2
abort_17:	strbt	r3, [r0], #1
		ldrge	r3, [r1], #0
abort_18:	strgebt	r3, [r0], #1
		movgt	r3, r3, lsr #8
abort_19:	strgtbt	r3, [r0], #1
		b	.c2u_finished

/*
 * Data access abort exit.
 */
exit_01:	ldmfd	sp!, {r0, r4 - r7, pc}


*2005/11/23 10:51:50 ARM convenience

PC:r15
LR:r14
SP:r13
IP:r12

eq: equal; Z set
ne: not equal; Z clear
cs/hs: carry set/ unsigned higher or same; C set
cc/lo: carry clear/ unsigned lower; C clear
mi: minus/ negative; N set
pl: plus/ positive or zero; N clear
vs: overflow; V set
vc: no overflow; V clear
hi: unsigned higher; C set and Z clear
ls: unsigned lower or same; C clear or Z set
ge: signed greater than or equal; N set and V set, or N clear and V
clear (N==V)
lt: signed less than; (N!=V)
gt: signed greater than; (Z==0, N==V)
le: signed less than or equal; (Z==1 or N!=V)
al: always 

*2005/11/23 14:03:10 更换键盘布局

今天看了一篇文章，说经常用 pinky 按 Ctrl 的话，容易让 pinky strain。这
个兄弟建议都用反方向的 thumb 按 Ctrl。我都用 palm 按 Ctrl，也感觉不大
舒服，不如把左 Windows 改成左 Control，右 Ctrl 和 右 Alt 对调，这样可
以实现都用 thumb 按 Ctrl。 

实现方法如下：
http://www.calmar.ws/vim/win-map/keymapping_win.html
加入 Scancode Map 键值，格式如下：
	0000 0000 0000 0000
	the number of `changes' + 1
	the changes themselves
	a `0000 0000' at the end
我现在已经有了
00 00 00 00 00 00 00 00
02 00 00 00 1D 00 3A 00
00 00 00 00
这个是把 Capslock 设置为 Ctrl 了。

我要加：（注意little endian系统，字节从右向左读）
1D 00 5B E0
1D E0 38 E0
38 E0 1D E0

这个大哥把 ESC 和 Capslock 对调了，也不错，加上：
去掉 1D 00 3A 00
加上 01 00 3A 00 3A 00 01 00

我一共改了五个地方，所以最后结果是
00 00 00 00 00 00 00 00
06 00 00 00 1D 00 5B E0
1D E0 38 E0 38 E0 1D E0
01 00 3A 00 3A 00 01 00
00 00 00 00

保存成 mykeymap.reg 文件导入再重新注册一下就可以了。

唉，导入注册表好像有点问题呀，还是自己手写吧。

*2005/11/24 10:13:36 WinXP 驱动

想不到装驱动也成了个需要技巧的活儿，这回得把装的过程记下来。

下面是发在驱动网论坛上的帖子内容。

同意dunniu的观点，我提供一个我自己出现的问题：设备IRP_MN_START_DEVICE
的时候读注册表的一个键值，按照这个键值整一些runtime的数据出来。在一般
的桌面系统上都没有什么问题，在一台笔记本上出现了“设备无法启动，错误代
码10”的问题。后来查出来是我读的那个键值，在笔记本的注册表里没有，那个
irp就返回失败了。自己手动加了那个键值，就可以正常安装了。

*2005/11/24 17:27:56 core dump 到文件

在 do_DataAbort 里直接写是不行的，因为所有的文件系统写都用了
copy_from_user ，在内核里调用会造成新的 data abort。

用另外一个进程，等待被监视的进程唤醒也不行， wakeup 会调用
_HAL_ContextSwitch, 这会造成内核的 mode 变乱，至于怎么变乱的，还需要再
研究。

最后解决的方法是在 do_DataAbort 里发一个信号给监视的进程。监视进程通过
访问一个驱动，来得到内核里保存的现场状态，再写到文件里。

这里还有一个小细节：在内核里把寄存器和栈一股脑拷贝到用户空间，在用户空
间做解析，用人可以读的方式写入文件，这样可以利用很多 c 库里提供的处理
字符串的函数，比在内核里处理方便多了。

*2005/11/25 09:24:52 修改两种字体的方法

(setq font-encoding-alist 
      (cons '("gb2312.1980" . chinese-gbk) font-encoding-alist))
(create-fontset-from-fontset-spec
 "-outline-Courier New-normal-r-normal-normal-14-*-*-*-c-*-fontset-most")
(set-default-font "fontset-most")
(set-fontset-font
 "-outline-Courier New-normal-r-normal-normal-14-*-*-*-c-*-fontset-most"
 'chinese-gbk 
 "-outline-新宋体-normal-r-normal-normal-16-*-*-*-c-*-gb2312.1980-0" nil nil)

(setq default-frame-alist 
      (append '((font . "fontset-most")) default-frame-alist)
      ) 

有待研究。

http://debian.cn99.com/debian/pool/main/e/emacs-snapshot/
这里有 emacs 的 snapshot

*2005/11/25 11:43:23 Data Abort 更多

vector_data:	@
		@ save mode specific registers
		@
		ldr	r13, .LCsabt
		sub	lr, lr, #8
		str	lr, [r13]
		mrs	lr, spsr
		str	lr, [r13, #4]
		@
		@ now branch to the relevent MODE handling routine
		@
		mov	r13, #I_BIT | MODE_SVC
		msr	spsr_c, r13

		and	lr, lr, #15
		ldr	lr, [pc, lr, lsl #2]
		movs	pc, lr

ldr 把.LCsabt 这个地址上的东西 load 到 r13 了, 在这里这个东西是
__temp_abt, 而这个 __temp_abt 又是一个预先分配的三个32位数的地址, 这三
个位置是为了保存 lr_abt, spsr_abt, 和 old_r0 设置的, 是为了进入不同的
mode 再回到 svc 时候, 可以方便的取到异常的现场. 这两个标签分别是如下定
义的:

.LCsabt:	.word	__temp_abt

__temp_abt:	.word	0				@ Saved lr_abt
		.word	0				@ Saved spsr_abt
		.word	-1				@ old_r0

lr 减去8保存到 __temp_abt 偏移量0的地方, 因为在 ARM Architecture
Reference  Manual June 2000 版的2.6.5, 提到 Data Abort 时候, R14_abt
的值为 aborted instruction 的地址加上8. 

CPSR[4:0] = 0b10111
CPSR[5] = 0
CPSR[6] unchanged
CPSR[7] = 1 disable normal interrupts

lr 和15与, 得到的数是 spsr 的低4位, 表示 Data Abort 时候的 mode, 左移
两位正好可以与后面对应的跳转地址对应上. 

__dabt_usr:	sub	sp, sp, #S_FRAME_SIZE
		stmia	sp, {r0 - r12}
		ldr	r4, .LCabt
		add	r3, sp, #S_PC
		ldmia	r4, {r0 - r2}
		stmia	r3, {r0 - r2}
		stmdb	r3, {sp, lr}^
		bl	cpu_data_abort
		mov	r2, #MODE_SVC
		msr	cpsr_c, r2
		mov	r2, sp
		adr	lr, ret_from_sys_call
		b	do_DataAbort

这里是 User mode 发生 Data Abort 时候跳转的地址. 这里用的 sp 应该是当
前进程的内核堆栈. 这里借用了, 把异常的现场保存在这里. 跳转到
cpu_data_abort 这个函数. 回来后 sp 保存到 r2 再调用 do_DataAbort,
do_DataAbort 回来后进入 ret_from_sys_call. 

/*
 * cpu_xscale_data_abort()
 *
 * obtain information about current aborted instruction.
 * Note: we read user space.  This means we might cause a data
 * abort here if the I-TLB and D-TLB aren't seeing the same
 * picture.  Unfortunately, this does happen.  We live with it.
 *
 *  r2 = address of aborted instruction
 *  r3 = cpsr
 *
 * Returns:
 *  r0 = address of abort
 *  r1 != 0 if writing
 *  r3 = FSR
 *  r4 = corrupted
 */
	.align	5
	.global cpu_data_abort
cpu_data_abort:
	ldr     r1, [r0]
	mrc     p15, 0, r0, c6, c0, 0
	tst     r1, r1, lsr #21
	mrc     p15, 0, r3, c5, c0, 0
	sbc     r1, r1, r1
	and     r3, r3, #255
	mov     pc, lr

这里应该是被改过了, r0 保存了中断现场的 pc 值, 

*2005/11/25 17:47:10 CVS in Emacs

C-u M-x cvs-update 可以问 update 的参数, 很方便. 

*2005/11/25 20:07:29 用 emulator 的奇怪事情

用 emulator 连虚拟串口以后, 发送关于多通道的命令无反应, 其后这个虚拟串
口保持忙的状态很长时间才能连接. 

*2005/11/27 22:04:45 VFS

The key idea behind VFS consists of introducing a common file model
capable of representing all supported file systems.

** The common file model consists of the following object types:

The superblock object:

The inode object: for a disk-based filesystem, this object usually
corresponds to a file control block stored on disk. Each inode is
associated with an inode number, which uniquely identifies the file
within the filesystem.

The file object: Store information about the interaction between an
open file and a process. This information exists only in kernel momery
during the period each process access a file.

The dentry object: Stores information about the linking of a directory
entry with the corresponding file. Each disk-based filesystem stores
this information in its own particular way on disk.

The most used dentry objects are contained in a disk cache named
dentry cache, which speeds up the traslantion from a filename to the
inode of the last pathname component.

** All information needed by the filesystem to handle a file is
included in a data structure called an inode. Each inode duplicates
some of the data included in the disk inode, for instance, the number
of blocks allocated to the file. When the value of the i_state field
is I_DIRTY, the inode is dirty, that is, the corresponding disk inode
must be updated. Other values of the i_state field are I_LOCK and
I_FREEING (which means the inode is being freed).

i_list field always appears in one of the following circular doubly
linked lists:

The list of inodes: The first and last elements are referenced by
inode_unused variable. This list acts as a memory cache.

The list of in-use inodes: The first and last elements are referenced
by the inode_in_use variable.

The list of dirty inodes: The first and last elements are referenced
by the s_dirty field of corresponding superblock object.

Inode objects belonging to the "in use" and "dirty" lists are also
included in a hash table named inode_hashtable by i_hash field. The
hash table speeds up the search of the inode object when the kernel
knows both the inode number and the address of the superblock object
corresponding to the filesystem the includes the file.

i_op field: 

create(dir, dentry, mode): creates a new disk inode for a regular file
associated with a dentry object in some directory.

lookup(dir, dentry): searchs a directory for an inode corresponding to
the filename included in a dentry object.

** A file object describes how a process interacts with a file it has
   opened. Notice that file objects have no corresponding image on
   disk, and hence no "dirty" field is included in the file structure
   to specify that the file object has been modified.

The size of list "unused" file objects is stored in the nr_free_files
variable. The get_empty_filp() function is invoked when the VFS must
allocate a new file object. The function checks whether the "unused"
list has more than NR_RESERVED_FILES items, in which case one can be
used for the newly opened file. Otherwise, it falls back to normal
memory allocation.



** Dentry Objects

Each directroy is considerd by the VFS as a normal file that contains
a list of files and other directories. Once a directory entry has been
read into memory, however, it is transformed by the VFS into a dentry
object based on the dentry structure.

A dentry object is created by the kernel for every component of a
pathname that a process looks up; the dentry object associates the
component to its corresponding inode.

No field is included in the dentry structure to specify that the
object has been modified. Dentry objects are stored in a slab
allocator cache called dentry_cache; dentry objects are thus created
and destroyed by invoking kmem_cache_alloc() and kmem_cache_free().

*** Each dentry object may be in one of four states:

Free: The dentry object contains no valid information and is not used
by the VFS. The corresponding memory area is handled by the slab
allocator.

Unused: The dentry object is not currently used by the kernel. The
d_count usage counter of the object is null, but the d_inode field
still points to the associated inode. The dentry object contains
valid information, but its content may be discarded if necessary to
reclaim memory.

In use: The dentry object is currently used by kernel. The d_count
usage counter is positive and the d_inode field points to the
associated inode object. The dentry contains valid information and
cannot be discarded.

Negative: The inode associated with the dentry no longer exists,
because the corresponding disk inode has been deleted. The d_inode
field is set to NULL, but the object still remains in the dentry cache
so that further lookup operations to the same file pathname can be
quickly resolved. The term "negative" is misleading since no negative
value is involved.

*** The Dentry Cache

All the "unused" dentries are included in a doubly linked "Least
Recently Used" list sorted by time of insertion. The list head is
stored in the dentry_unused variable.

Each "in use" dentry object is inserted into a doubly linked list
specified by the i_dentry field of the corresponding inode object. The
d_alias field of the dentry object stores the addresses of the the
adjacent elements in the list.

The fields of d_op are usually NULL, and the VFS replaces them with
default functions.

*2005/11/28 14:15:43 DA9030 charger

电压传感器比 VCHGTH 小, 并且电流传感器比 ICHTH 小, 并且经过 CDD 时间间
隔后, 认为充电器没有了. 遗憾的是, 这几个值都是固定的.

尝试了一个下午, 发现并非温度过高或者电流过大引起的问题. 明天来在
bootloader 里用查询的方式看看是否有这样的情况吧.

esha 的意思是充电器连上电池后, 电压不能达到5.x伏了, da9030 就认为充电
器被拔掉了. 可是我在板子上实验, 并没有这样的情况发生. 

*2005/11/29 16:42:33 mounting, pathname searching, syscall, locking

** Mounting

While the system boots, it finds the major number of the disk
containing the root filesystem in the ROOT_DEV variable. The mount
flags of the root filesystem are stored in the root_mountflag
variable. The user can specify this flags by using the /sbin/rdev
external program on a compiled kernel image.

mount_root() 都是从 prepare_namespace 调用的. 

Mounting the root filesystem is a two-stage procedure: 

1. The kernel mounts the special rootfs filesystem, which just provides
an empty directory the serves as initial mount point.

2. The kernel mounts the real root filesystem over the empty directory.

start_kernel -> vfs_caches_init -> mnt_init -> init_rootfs
start_kernel -> vfs_caches_init -> mnt_init -> init_mount_tree ->
do_kern_mount("rootfs", 0, "rootfs", NULL)

ramfs 和 rootfs 用的同一个 read_super 函数: ramfs_read_super. 

第二阶段的 mount 操作是 

init -> prepare_namespace -> mount_root

可是我没有找到 init 这个函数在哪里调用的, 它是 main.c 的 static 函数,
可是  main.c 里没有地方显示的调用了它. 不过看样子, init 是比较靠后的函
数了, 已经到了运行初始化程序或者 sh 的地方了.



