* Linux Kernel

** Signal

*** Posix 1003.1

   - Signal handler must be shared among all threads of a multithreaded application; however, each thread must have its own mask of pending and blocked signals.

   - Signals are sent to whole multithreaded application, not to a specific thread.

   - Each signal sent to a multithreaded application will be delivered to just one thread, which is arbitrarily chosen by the kernel among the threads that are not blocking that signal.

   - If a fatal signal is sent to a multithreaded application, the kernel will kill all threads of the applicationnot just the thread to which the signal has been delivered.


** Speed Up Linux Boot up

*** Some tips

   * reduce the number of daemons
   * some daemon can be converted to application on demand - if only you can speed up its start
   * Prelink needs -fPIC binary
   * optimize the size and load speed of shared libraries
   * put shared libraries in one reasonable place
   * define a good search order for shared libraries

** Memory

*** Size

 - to get to know how much memory it uses?

<code>
#dmesg | grep Memory
<6>[    0.000000] Memory: 244MB = 244MB total
<5>[    0.000000] Memory: 230776KB available (4660K code, 1079K data, 212K init)
</code>

  - And don't forget to add those used by modules.


<code>
#lsmod
modem_pm_driver 2228 2 - Live 0xbf018000
netmux_linkdriver 9996 0 - Live 0xbf013000
netmux 55768 21 netmux_linkdriver, Live 0xbf000000
</code>

*** mapping

 - Final page tables are setup by paging_inig().
<code>
        void *zero_page;

        build_mem_type_table();
        sanity_check_meminfo();
        prepare_page_table();
        bootmem_init();
        devicemaps_init(mdesc);

        top_pmd = pmd_off_k(0xffff0000);

        /*
         * allocate the zero page.  Note that this always succeeds and
         * returns a zeroed result.
         */
        zero_page = alloc_bootmem_low_pages(PAGE_SIZE);
        empty_zero_page = virt_to_page(zero_page);
        flush_dcache_page(empty_zero_page);
</code>

   - build_mem_type_table() is to adjust the PMD selection entries according to the CPU in use. Manipulating mem_type[];

   - prepare_page_table() cleans up pmd's

   - kernel page table is indexed by struct mm_struct init_mm, which is a static varable. The most important member of it is init_mm.pgd, which is initialized with swapper_pg_dir. 

   - pgd_t swapper_pg_dir[PTRS_PER_PGD] is the virtual address of the initial page table. We place the page tables 16K below KERNEL_RAM_VADDR.  Therefore, we must make sure that KERNEL_RAM_VADDR is correctly set.  Currently, we expect the least significant 16 bits to be 0x8000, but we could probably relax this restriction to KERNEL_RAM_VADDR >= PAGE_OFFSET + 0x4000.

   - Then, where's the 0xFFFF001C is mapped to? In mmu.c, it is mapped to a page in bootmem. 

** System settings

*** change the profile of system services

Runlevels represent the profiles of system services. One line in /etc/inittab can change the system behavior.

<code>
_id:3:_ initdefault:
</code>

It should be a bug in ubuntu 8.04 where append runlevel number to kernel parameter line in grub doesn't work.

*** apt

To setup apt proxy

<verbatim>
$cat /etc/apt/apt.conf
Acquire {
    http {
        Proxy "http://wwwgate0.mot.com:1080";
    }
}
</verbatim>

** Data Types

   - linked list
<verbatim>
LIST_HEAD(foo)
list_add(&bar->list, &foo);
list_del_init(&bar->list); /* iterate through the list deleting every member */
list_add(&bar->list, &foo); /* the list can be reused without initializing it */
 </verbatim>

** uevent in Android platform
*** usage of sysfs

   - linux 2.6.28.3/Documentation/sysfs-rules.txt

says _user space applications shall not rely on things in sysfs other than devices, such as class-, bus-, physical devices, interfaces, etc_. Those types are just kernel implementation details which should not be expected by applications that look for devices in sysfs.

   - linux 2.6.28.3/Documentation/filesystems/sysfs.txt

The directory structure in sysfs embodies the inheritance relationships. Sysfs internally stores the kobject that owns the directory in the -&gt;d_fsdata pointer of the directory's dentry.

** device management in Android platform

The device management of Android is in system/core/init/device.c and some other files. The mechanism is simple.

In the function _handle_device_fd()_, a endless loop is reading the netlink socket and pass the data to function handle_device_event() to create devices.

handle_device_event() create the device in one of subsystems graphics, oncrpc, adsp, input, mtd, snd, log in /dev.

** Kernel Oops

 - *no more ksymoops utility in 2.6*

*** where's the Oops?

 - log buffer -> klogd -> syslogd -> /var/log/messages
 - /proc/kmsg

*** How to track it down?

There are three methods to disassemble it:

 - for well reported oops (you may want to know [[BuildVmlinux][how to build vmlinux]])

<verbatim>gdb /usr/src/linux/vmlinux
gdb> disassemble <offending_function></verbatim>

 - to disassemble the _code_

you can do a silly program:<verbatim>char str[] = "\xXX\xXX\xXX...";
int main(){return 0;}</verbatim>

compile it with -g and do "disassemble str"


 - to find it in assembly code

<verbatim>
cd /usr/src/linux
make fs/buffer.s
</verbatim>


** Timer

*** How does select() use timer? 

 int core_sys_select() :: using hrtimer with schedule_hrtimeout_range()
 int poll_select_copy_remaining() :: It copies remaining seconds to go if select() is interrupted.


*** high resolution timer and MONOTONIC clock as well as REALTIME clock

 - select() use CLOCK_MONOTONIC clock to count time, via hrtimer interfaces.
 - CLOCK_REALTIME can be changed by ntp service or so, but CLOCK_MONOTONIC doesn't.
 - there is no persistent clock in arm arch, which, by design, is to track real time from device bootup, including suspend period.

*** Watchdog Timer

 - x86 and ia64 have NMI watchdog interrupt. As mentioned in mn10300-watchdog.c, the best way to detect whether a CPU has a 'hard lockup' problem is to check its timer makes IRQ counts. 

 - In interrupt handler, mn10300-watchdog.c compares irq count to that of last time interrupt tiggered. If the counts are equal, CPU is assumed to be dead. 

 - sparc64 doesn't have a real NMI, so the developers fake one up using profiling counter overflow interrupts. 

 - *I'm still not sure how x86 handle watchdog NMI*

 - the mn10300-watchdog and sparc watchdog NMI handler, they both get irq_stat[cpu].__irq_count or kstat_irqs_cpu(0, cpu) to check whether or not the cpu is locked up. 

 - softlockup_tick(), who runs from the timer interrupt, wakes up watchdog thread to update touch_timestamp every softlockup_thresh/2 period of time. So if the touch_timestamp isn't changed in next running session, softlock_tick() complains. 

 - so what? If timer interrupts are even disabled, we have to get something else to check out the error in this circumstance. 
** module
** Traps
** trace

Kernel provides a general method for every component. The pr_ macro set: 

 - #define pr_emerg(fmt, ...) printk(KERNEL_EMERG pr_fmt(fmt), ##__VA_ARGS__)
 - #define pr_alert(fmt, ...) printk(KERNEL_ALERT pr_fmt(fmt), ##__VA_ARGS__)
 - ...

where pr_fmt can be defined by each component. For example, in phram.c it is defined as  "phram: " fmt. And the ipvs (net/netfilter/ipvs/) defines KMSG_COMPONENT as IPVS.
