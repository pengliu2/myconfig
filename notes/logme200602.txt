*2006/02/05 16:11:16 emacs script 设想

可以编写 script, 进入 outline mode 以后绑定F5, 当光标处于展开的 body
里, F5 隐藏这个 body, 否则, F5 显示这个 body.

需要查的是判断当前 entry 是否展开的函数.

outline.el 提供了一个比较简单的函数, outline-toggle-children, 姑且用之.
隐藏的时候全部隐藏, 显示的时候显示 children 标题和本标题的 entry.

*2006/02/06 11:02:56 outline

一个设置 outline 的脚本

;; outline
  (add-hook 'outline-mode-hook
          '(lambda ()
             (setq outline-regexp "\\(\\*\\|-\\|  -\\|    -\\)")
             (setq outline-level
                   '(lambda ()
                      (cond ((looking-at "\\*") 1)
                            ((looking-at "-") 2)
                            ((looking-at "  -") 3)
                            ((looking-at "    -") 4)
                            (t 1000))))))
  (setq outline-font-lock-keywords
    '(;;
      ;; Highlight headings according to the level.
      (eval . (list (concat "^" outline-regexp ".+")
                  0 '(or (cdr (assq (outline-font-lock-level)
                                    '((1 . font-lock-function-name-face)
                                      (2 . font-lock-variable-name-face)
                                      (3 . font-lock-doc-face)
                                      (4 . font-lock-comment-face)
                                      (5 . font-lock-comment-face)
                                      (6 . font-lock-type-face)
                                      (7 . font-lock-type-face)
                                      (8 . font-lock-string-face))))
                         font-lock-warning-face)
                  nil t))))

*2006/02/07 12:37:23 关于房贷

设贷款额度为 M0. 设贷款发放的事件是 t0, 第一个还贷款的事件是 t1, 这中间
的利息是 p01. 第一个月还的钱 X1 中, p01用于补上利息了, 剩下的 (X1 -
p01) 用于还本金 M0.

这样下个月计算利息的时候就按照 M0 - (X1 - p01) 来算了. 这样, 即使 t1 -
t0 == t2 - t1, 因为本金总额少了, 第二次还钱时候的利息 p12 会比 p01 少.

在计算下一次本金的式子 M0 - (X1 - p01) 中, 如果 X1 变大, 那式子的结果,
也就是下一次本金也会减少, 那么下一次还钱时候利息也会减少. 因此, 刚开始
还钱的时候, 增加还的钱数, 即使同样是 20 年还完, 也可以使最后还的本金和
利息总额减少.

更一般的, 第 n 次还钱后, 本金为 Mn = M(n-1) - (Xn - p(n-1,n)). 无论何时
还清贷款, 当 n 为最后一次还钱的时候, Mn == 0, Xn = M(n-1) + p(n-1, n).

给定 M0 和 n 和利息率, 如何求 X 呢?

X = M(n-1) * p + M(n-1)

2X = M(n-2) * p + M(n-1) * 2p + M(n-2)

3X = M(n-3) * p + M(n-2) * 2p + M(n-1) * 3p + M(n-3)

(n-2)X = M2 * p + M3 * 2p + ... + M(n-1) * (n-2)p + M2

nX = M0 * p + M1 * 2p + ... + M(n-1) * np + M0

其中 M0, p, n都是常数, 解这个方程组就可以了. 解这个方程组, 可以把 M 都
用 X 表示出来, 变成一个一元一次方程.

M(n-1) = X / (1 + p)

M(n-2) = 2X / ((1 + p) ^ 2)

...

M2 = (n-2)X / ((1 + p) ^ (n-2))

M1 = (n-1)X / ((1 + p) ^ (n-1))

nX = (n-1)(2p)X / ((1 + p) ^ (n-1)) + (n-2)(2p)X / ((1 + p) ^ (n-2)) +
... + 4pX / ((1 + p) ^ 2) + 2pX / (1 + p) + M0 * (1 + p)

*2006/02/07 13:25:30 HOPEN3.0 modification

fs.h, select.h, kernel/libhopen/stdlib/select.c: enlarge max_fs to 128

hal_idle.c: CPU_idle can be implemented by driver

hal_mmutrap.c: core dump

hal_console.c: nonblock console output

kernel/libhopen/api_20/fs_dir.c, kernel/libhopen/api_20/fs_uartrd.c,
kernel/libhopen/api_20/ioctl_20.h: add api20 serial ports

kernel/libhopen/api_20/fs_uartrd.c: poll uart whenever writing failed
despite errno

kernel/mm/mm-memory.c: don't block user's malloc

kernel/mm/mm-pgalloc.c: warning when memory is low

