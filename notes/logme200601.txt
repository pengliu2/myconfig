*2006/01/02 11:21:32 contract

第三章 劳动合同和集体合同
第三十二条 有下列情形之一的，劳动者可以随时通知用人单位解除劳动合同：

　　（一）在试用期内的；
　　（二）用人单位以暴力、威胁或者非法限制人身自由的手段强迫劳动的；
　　（三）用人单位未按照劳动合同约定支付劳动报酬或者提供劳动条件的。

*2006/01/04 09:40:32 Ext2 file open and close
** open

sys_open -> filp_open -> open_namei
sys_open -> filp_open -> dentry_open

*** dentry_open

先从简单的 dentry_open 看起, 在 open.c 文件里. 这时候, dentry 和
dentry 对应的 inode 已经由 open_namei 设置好了. 

这个函数主要是设置文件对应的 file 结构, 其中, 用 fops_get 获得
f_op. file_move 不知道是做什么用的. 如果 f_op 有 open 方法就调用之. 这
正是我要追寻的.

可以参看下面的文字, 这里的 f_op->open 就是 ext2_file_operations ->
generic_file_open, 或者, ext2_dir_operations -> NULL.

fops_get 增加模块使用数. 

file_move 是把新生成的 file 加入到 super_block 的 s_files 队列里面.

*** open_namei

如注释说的, 这个函数 almost the whole open-routine.

简单的部分, 没有加 O_CREAT 的 open, 调用 path_init 和 path_walk, 不管
有没有找到都会返回. 

如果加了 O_CREAT, 需要知道 parent.

先看 path_init: 设置 nd 的 last_type, flags, mnt, dentry 等成员. 

path_walk: 设置 current->total_link_count 为 0. 调用 link_path_walk. 

link_path_walk: 先去掉前面的'/', hash 一个目录名字, 如果是最后一个名字,
去 last_component, 如果最后一个是'/', 去 last_with_slashes.

如果头两个字符是"..", 调用 follow_dotdot, 这个函数很简单, 如果当前是根,
直接返回, 如果当前是文件系统自己的根, 找父文件系统里面的那个
mnt_parent, 把 nd 的 mnt 设置为这个值, dentry 设置为 mnt_mountpoint, 再
继续follow_dotdot, 其实就是 follow 父文件系统的了. 都不是的话, 找自己的
d_parent 就行了.

我们的 ext2 根, 就没有设置 d_op. 

两个重要的函数, cached_lookup 和 real_lookup. 前者和文件系统没有什么关
系, 先不看.

找到这个 dentry 之后, 查看是否有其他文件系统 mount 在上面, 如果有,
__follow_down. 如果 inode 有 follow_link, 调用.

parent 的 d_inode 在什么地方设置的?  在 ext2_read_super 里, 分配s_root
的时候, 通过 iget -> iget4 -> get_new_inode -> sb->s_op->read_inode 设
置的.

ext2_read_inode: EXT2_ROOT_INO 为 2. 无论如何, block_group 应该是
0. group_desc 是 block_group 右移一些位.

需要看一下 read_super 里面装载 s_group_desc 的部分. ext2_read_inode 直
接访问了数组 s_group_desc. s_inodes_per_block 是 s_blocksize 可以装多
少 inode. s_desc_per_block 是每个 block 可以装多少 desc.

s_group_sesc 是从 super block 后面开始读的.

内核 sb 里的保存的 s_inode_bitmap_number, s_inode_bitmap,
s_block_bitmap_number, s_block_bitmap, 都是 disk 上相应数据的 cache.

ino 其实给出了 inode 和 group_desc 的线性对应关系. 以及 inode 在
group_desc 内部的 bg_inode_table 的影射关系. 从而得到了 inode 所在的
block, 读取这个 block.

gdp 指向这个 group 的 ext2_group_desc.

offset 是这个 inode 在这个 ext2_group_desc 里的字节偏移量.

得到 raw_inode. 根据这个 raw_inode, 设置内核 inode 的值, 还根据 ino 的
值, 设置了 i_op 和 i_fop 以及 i_mapping. 一般文件是 i_op =
ext2_file_inode_operations, i_fop = ext2_file_operations, 目录是 i_op
= ext2_dir_inode_operations, i_fop = ext2_dir_operations.

ext2 的 ext2_file_inode_operations 只有一个 truncate 方法.

还设置了 i_mapping 的 a_ops, 为 ext2_aops.

** close

filp_close 调用文件系统的 f_op->flush 方法. 可是我们的 ext2 好像没有定
义这个方法. 那数据 flush 的操作应该是在 umount 里做的了.

** umount

按照注释说的. 如果是 umount root, 那就把 root 用只读方式重新 mount. 如
果有别的文件系统 mount 在上面, 就返回 EBUSY. 这里还是没有 flush. 要看一
下情景里面怎么说的 (偷懒了, 呵呵).

情景里提到 shrink_dcache_sb, 我们的 umount 里面没有调用这个函数, 但是在
do_remount_sb 里调用了. 这是不是意味着, 除非整个系统关掉, 否则不 flush
呢?

shrink_dcache_sb 还在 invalidate_device 里被调用, 如果设备是可移动的设
备, 是否调用的就是这里的 shrink_dcache_sb 呢?

我看到的 shrink_dcache_sb 没有起到写回 sync 或者说 flush 的作用, 起到这
个作用的还是 fsync_dev. fsync_dev 里面调用到了 sync_inode, 里面调用到了
write_inode 方法, 对应的应该是 ext2_write_inode, 后面写文件时候也许也要
用到.

ext2_write_inode -> ext2_update_inode

*2006/01/04 12:22:54 OpenOffice

用新加坡那个 ftp 下载比较快.

*2006/01/05 15:00:38 Ext2 file writing

ULK2 15.1.3

ext2 的 write 方法直接用了 generic_file_write. 这个函数是在
mm/filemap.c 这个文件里, 有点奇怪.

i_mapping 是哪里设置的? page 里不止一个 block 的数据, 不能通过 device
number 和 block number 来确认了. 就用了个新的 内核数据结构
address_space 来管理 page.

14.1 里面介绍了 address_space. The page cache includes five kinds of
pages, so a page may belong to five possible kinds of owners: a
regular file, a directory, a block device file, a swap area, where is
the fifth?

inode->i_data: address_space object for block device file. 

inode->i_mapping: Pointer to an address_space object.

我就是想看 prepare_write: The prepare_write function takcs care of
allocating asynchronous buffer heads for the page and os reading some
buffers from disk, if necessary.

prepare_write 的参数, file, page, offset, end of what write to this
page.

进去后调用了 block_prepare_write(page, from, to, ext2_get_block) 对于
ext2 文件系统. 里面最重要的是 ext2_get_block, 它把 block number
relative to the file into a logical block number.

这就要看 17.6 Managing Ext2 Disk Space 了.

如果新的 inode 是目录, 找一个 block group 把 inode 写进去, 使得目录都平
均分到部分填满的 block group 里. 特别的, 把新的目录分配到这样的 block
group 里, 这个 block group 在所有高于平均空闲 inode 数的 block group
里, 拥有最多的空闲 block 数.

如果新的 inode 不是目录, 选择 block group 是从包含父目录的 block group
找开来的. 具体的说, 先是用 current mod total, current+1 mod total,
current+1+2 mod total, current+1+2+4 mode total, 找. 如果没有找到拥有空
闲 inode 的, 就再从 current 线性查找.

*2006/01/10 11:32:45 white LCD

LCD 从睡眠里被唤醒以后, LCD controller 都重新设置了, 因此不应该存在
LCDC 有错误的问题.

*2006/01/10 14:26:53 USB 线连接后快速断开, 手机所有线程等待.

调度到 USB_task 后才能创建 Event, 如果快速拔掉, SetEvent 设置的是一个空
的 Event, 线程被调度到的时候, 就等死在那个 Event 上了.

*2006/01/11 09:39:33 PXA271 时钟电源状态

Reset Manager: five reset state: power on, haredware, watchdog, GPIO,
sleep-exit(exit from sleep or deep sleep mode) reset.

Several GPIO pins are used as standby and sleep wake-up sources. GPIO
3, 2 and 1 pins are used as a standby, sleep, and deep-sleep wake-up
sources.

There are masks to determine which input can wake up PXA271.

low-power mode: standby, sleep, deep-sleep.
