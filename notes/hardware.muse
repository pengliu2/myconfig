* Hardware

** OMAP 4 Platform 

The omap4 is based on coretex A9 core unveiled by ARM co. ARM co. touted its multi-core architecture in May 2004.

Details of OMAP4 can be found at (may slow down the machine because of video in this page) http://focus.ti.com/general/docs/wtbu/wtbuproductcontent.tsp?templateId=6123&navigationId=12842&contentId=53247&DCMP=WTBU&HQS=Other+PR+omap4

*** I/O pad control

 - in standby mode, I/O pad can be configured to detect wake-up events and wake up the device

 - based on the following configuration
  - I/O pad logic
  - SCM
  - PRM
 - 

(below part needs to be moved to device driver)
** Serial and tty driver

*** lower functions 

The internal functions accessing data buffer analyzed below. Seems they are used by those [[TTYFlip][flip functions]].

In 2.6.11, tty_struct has a member _flip_ in type _struct tty_flip_buffer_, while in 2.6.27, it's replaced by _buf_ in type _struct tty_bufhead_.

_struct tty_struct {_ <em>

...<br />struct tty_bufhead buf;<br />...
</em> _}_

_struct tty_bufhead {_ <em>

struct delayed_work work;<br />spinlock_t lock;<br />struct tty_buffer *head;<br />struct tty_buffer *tail;<br />struct tty_buffer *free;<br />int memory_used;
</em> _}_

_struct tty_buffer {_ <em>

struct tty_buffer *next;<br />char *char_buf_ptr;<br />unsigned char *flag_buf_ptr;<br />int used;<br />int size;<br />int commit;<br />int read;<br />unsigned long data[0];
</em> _}_

I checked the functions in tty_io.c of 2.6.27:
   * initialize_tty_struct

In the very beginning, head and tail and free in tty-&gt;buf are initialized as NULL. memory_used as 0. delayed_work is flush_to_ldisc.
   * tty_buffer_free_all

This function is called from free_tty_struct, which is a cleanning up function. From this function we can know that buf.head and buf.free are two header of linked list. The function just free each element in the two linked list. But a question here is why it will not cause memory leak? It seems there is no freeing method on the data member of tty_buffer. OK. It will not cause memory leak, because function tty_buffer_alloc allocates the struct in a whole memory block.
   * static struct tty_buffer *tty_buffer_alloc(struct tty_struct *tty, size_t size)

The function allocates a tty_struct which has 2*size bytes of additional memory block. char_buf_ptr in the tty_struct is set to point to the first size, and the flag_buf_ptr to the second. I don't why till now. This function is called from tty_buffer_find.
   * tty_buffer_find

This function is simple, finding free buffer in free list, allocating new if no empty in free list.

   * tty_buffer_request_room

If left space in last buffer is enough, return it. Or allocate a new buffer.

---++ interface to user space
---+++ line discipline

Low level data are inserted into line discipline with function flush_to_ldisc(). The tty ocre also gets data from line discipline and transfer it to user space applications.

By default, tty core setups the default tty line discipline in console_init() with tty_ldisc_begin(). The implementation is in n_tty.c.

   * int tty_insert_flip_string(struct tty_struct *tty, const unsigned char *chars, size_t size)
<div style="margin-left: 40px;">Ensure that buf.tail has enough space using _tty_buffer_request_room()_. Then copy the _chars_ into it.
</div>
   * int tty_insert_flip_string_flags(struct tty_struct *tty, const unsigned char *chars, const char *flags, size_t size)
<div style="margin-left: 40px;">The flags are copied to the second half of buf.data which is referred to by flag_buf_ptr. The flags can be
   * TTY_BREAK
   * TTY_PARITY
   * TTY_FRAME
   * TTY_NORMAL
   * TTY_OVERRUN
I don't need them in the simulating serial driver.
</div><div style="margin-left: 40px;">
</div>
** FIQs of ARM

 - FIQs bank r8-r13. While, ode produced by a C compiler compliant with ARM's ATPCS procedure call standard will instead use registers r0-r3 for scratch values and will not produce the correct cpsr restoring return code at the end of the function.

 - ARM Linux provides a standard function set for fiq handling: 
   - int claim_fiq(struct fiq_handler *f)
   - void releaes_fiq(struct fiq_handler *f)
