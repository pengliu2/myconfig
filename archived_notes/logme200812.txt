* 2008/12/10 11:19:07 build android in ubuntu 8.04

don't forget to run 
sudo update-java-alternatives -s java-6-sun

* 2008/12/10 11:23:53 kernel panic dumping

** categorizing

There are several kinds of ways to save kernel panic context, to NVM
or remote machine; using paniced kernel or new tiny one; whether
picked up by kernel.org.

** LKCD

*** requirements

**** a map file providing the symbol table of the kernel. 

generated automatically when the kernel is built. normally installed
under /boot/System.map

**** a dump file containing the image of a system's memory to be
     analyzed.

**** an object file in "stabs" debug format providing information of
     Kernel data type. (Kenrel data type is important!!) need a
     specific kernel patch to generate it (it's true in 2002, not sure
     current status).

*** commands

deftask: set/display the default task
dis: display the disassembled code
dump: display dump
findsym: display symbol information for given symbol addresses and
names
livedump: create a system dump form live system memory
mktrace: construct a stack backtrace from scratch
mmap: construct a stack backtrace from scratch
module: display information for module structs
namelist: add type information from namelist, list opened namelists
page: display information for page structs
report: display a crash dump report
stat: display system statistics and the log_buf array
strace: display all complete and unique stack traces
task: display information for task_struct structs
trace: display stack trace for task_struct
vtop: determine the physical address of an virtual one
walk: walk a linked list of kernel structures or memory blocks
whatis: display type information and symbol information

** kdump

*** advantages

**** filter:

full dump or kernel-pages only dump
dump to disk or across the network

*** components

**** user space tool -- kexec-tools

load a new kernel using kexec -l <kernel-image> --append=<options>

**** kernel system call (sys_kexec_load)

load capture kernel using kexec -p <kernel-image> --append=<options>

execution of capture kernel in panic() and Alt-Sysrq-c

reserve memory for capture kernel (crashkernel=X@Y, maybe 32M needed)

** mini kernel dump

also use kexec but after modified

where as kexec loads the kernel in piecemeal simgle page units, mkexec
loads contiguously
mkexec allocates memory space needed for the mini-kernel to operate
kexec boots up the kernel after having copied it to its original
location. mkexec doesn't copy

* 2008/12/11 00:00:56 iBT score

今天给 TAMU 送了 iBT 分数，据说 iBT 分数最长一个月才能到！
* 2008/12/12 10:06:07 show dialog in command line

gdialog - display dialog boxes form shell scripts

yes/no box
menu box
input box
text box
info box: gdialog --infobox text height width
checklist box
radiolist box
gauge box

* 2008/12/12 19:53:07 echo in android init.rc

add ERROR(_TRACE_MSG_) in init.c

* 2008/12/12 20:05:20 java in 2008

** alternate languages for the JVM

JRuby/Ruby on Rails and Groovy/Grails

Scala, Clojure, functional languages

Jython, 

JavaFX Script: the first Java-based language intented for rich UI
development

* 2008/12/16 10:14:38 QualComm Presentation on Android

** kernel patches

ashmem, binder, power management, low memory killer, kernel debugger,
logger, usb functiondriver

** HAL

allows for kernel drivers or proprietary user-space drivers 

supports drivers without standard APIs (e.g. vibrator)

** boot Linux

init RAM, create ATAGS, cmdline args, r0/r1/r2

** fastboot protocol

** Kernel or User-space driver?

*** kernel

must be GPL

kernel manages multiple clients, security based on file permissions

excellent linux driver model

leverages existing kernel drivers

*** user-space library (part of the HAL)

can be propietary

use UIO or lightweight driver to map hardware memory and proxy
interrupts

may perform better (no need to trap into kernel, sometimes no copying)

more difficult to support multiple clients

security is important: kernel must ensure user-space does not program
HW to scribble over system memory

3D graphics driver is an example

*** crashed modules/devices

RIL, modem - system must allow for modem restart

* backup

** toefl

Test  	 Test Date  	 Reading  	 Listening  	 Speaking  	 Writing  	 Total
TELXML 	November 1, 2008 	29 	27 	15 	24 	95 

** GRE

06/08 330 740 3.0

* 2008/12/24 13:35:41 tools working as ldd

static void show_so_dependance(bfd* b, asection* s)
{
    char* str  = NULL;
    char* buff = NULL;
    size_t length = 0;

    length = s->size;
    buff = (char*)malloc(length + 1);
    bfd_get_section_contents(b, s, buff, 0, length);
    buff[length] = '\0';

    for(str = buff; str < (buff + length); str += (strlen(str) + 1))
    {
        if(strstr(str, ".so") != NULL)
        {
            printf("  ");
            printf("%s\n", str);
        }
}
    free(buff);

    return;
}

int main(int argc, char* argv[])
{
    int i = 0;
    bfd* b = NULL;
    asection* s = NULL;
    char **matching = NULL;

    bfd_init();

    if(argc < 2)
    {
        printf("usage: %s filename\n", argv[0]);

        return 0;
    }

    b = bfd_openr(argv[1], NULL);
    if(bfd_check_format_matches (b, bfd_object, &matching))
    {
        if((s = bfd_get_section_by_name(b, ".dynstr")) != NULL)
        {
            show_so_dependance(b, s);
        }
    }
    bfd_close(b);

    return 0;
}

gcc -g depend_so.c -lbfd -liberty -o depend_so

[root@lixj bfd]# ./depend_so /usr/bin/xmlwf
  libexpat.so.1
  libc.so.6
  /lib/ld-linux.so.2



* 2008/12/29 15:22:02 linux memory categories

user virtual addresses

physical addresses

bus addresses

kernel logical addresses

kernel virtual addresses

** composing of address

address >> PAGE_SHIFT = PFN (page frame number)

** addresses translating

*** struct page *virt_to_page(void *kaddr)

takes a kernel logical address and returns its associated struct page pointer

*** struct page *pfg_to_page(int pfn)

returns the struct page pointer for the given page frame number

*** void *page_address(struct page *page)

returns the kernel virtual address of this page, if such an address
exists. In most case, use kmap.

*** void *kmap(struct page *page)

returns a kernel virtual address for any page. It maps high memory
address if it is not mapped yet.

* 2008/12/30 13:48:46 how much memory the linux kernel is using?

http://kbase.redhat.com/faq/docs/DOC-15301

Assessing exactly how much memory the Linux kernel is using at any moment in time is not an easy task, as the value is constantly changing with system activity. With a reasonably quiet system, it is possible to calculate an approximate interval within which the exact value lies.

 

The values present in the /proc/meminfo virtual file are used in the calculation, but as that file reflects instant snapshots of various kernel memory information, its contents can change anytime. In order to calculate the interval where the kernel memory consumption lies one should either take a copy of that file or display it in a terminal, and use the values in the copy or display.

 

The values at the limits of the interval are the floor, which starts from nothing and adds all values in /proc/meminfo with are known to belong to kernel objects, and the ceiling, which starts from the total memory in the system and subtracts all values in /proc/meminfo which are known to belong to userlevel processes (data pages, code, open files, etc).

 

Floor := Slab + PageTables
Ceiling := MemTotal - MemFree - Active - Inactive

 

The real kernel memory usage lies between these floor and ceiling values. The majority of kernel memory allocations happen in slab caches (Slab value in /proc/meminfo), which are dynamic memory pools for allocating frequently used data structures. By looking at /proc/slabinfo or using the slabtop command, it is possible to monitor the kernel allocations per object type and how they dynamically adapt to system load and memory pressure from userlevel processes.

 

If the system is configured to use Huge Pages, one should also remove from the ceiling value the amount of memory allocated to them. This takes into account both the total number of Huge Pages and their size (which can vary on different kernel versions and architectures). So for a system using Huge Pages the ceiling calculation becomes:

 

Ceiling := MemTotal - MemFree - Active - Inactive - (HugePages_Total x Hugepagesize)

 

These estimations are reliable enough for system accounting purposes, and can be used as one of the datapoints when investigating a suspect memory leak in the kernel (specially the interval size, that is, the difference between floor and ceiling, as it represents the amount of not-easily-accounted-for memory consumption).

 

The values may not always be completely accurate or stable if the system is having non-trivial activity, as the entries in /proc/meminfo are generated by on-demand calculations without locking. If the system undergoes spikes in activity, very different values can be obtained within milliseconds of each other as the system adapts to the load. In any case, even if the values in a /proc/meminfo snapshot do not seem to be consistent with each other, one can be assured that the kernel keeps a precise and consistent account of the memory consumption of the system for its own purposes.


