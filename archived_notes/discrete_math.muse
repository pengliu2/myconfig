* Discrete Mathematics

** Chapters of This Book:

 1. Foundations: Logic and Proofs
 2. Basic Structures: Sets, Functions, Sequences, and Sums
 3. The Fundamentals: Algorithms, the Integers, and Matrices
 4. Induction and Recursion
 5. Counting
 6. Discrete Probability
 7. Advanced Counting Techniques
 8. Relations
 9. Graphs
 10. Trees
 11. Boolean Algebra
 12. Modeling Computation

 Core Sections :: <br>1.1-1.7<br>2.1-2.4<br>3.1-3.5, 3.8<br>4.1-4.3<br>(359 counting)5.1-5.3<br>(417discrete probability)6.1<br>(473 advanced counting technology)7.1, 7.5<br>(543 relations)8.1, 8.3, 8.5<br>(613 graphs)9.1-9.5<br>(707 trees)10.1

 Optional Computer Science Sections :: <br>3.6<br>4.4, 4.5<br>5.6<br>6.4<br>7.3<br>8.2<br>10.2, 10.3<br>(773 boolean algebra)11.1-11.4<br>(809 modeling computation)12.1-12.5<br>

Chapter6-9,11,12 depend on Chapter1-5, Chapter 10 depends on 9.

** My Questions:

*** Rev. 6 Chapter 1.7 Example 12 The Chomp Game

 - Why don't we need to prove there is a winning pattern at the last several steps? If we don't prove this, the proposition may not be proved because there may be an initial case that the first player cannot find his/her first step toward the winning strategy. 

 - Hence, 1X1 case is an example for my question. 

*** Rev. 6 Chapter 3.1 Lemma 1

 - I don't understand what the author wants to state here. Perhaps he's wrong to put word _quarters_ in the first line. 

*** Rev. 6 Chapter 2.4 Example 20 and 21

 - They seem implying the set is countable if and only if all elements can be listed. Why? I didn't see any proof.  

*** Rev. 6 Chapter 3.2 

 - Donald E. Knuth: He applied his intelligence in unconventional ways, winning a contest when he was in the eight grade by finding over 4500 words that could be formed from the letters in "Ziegler's Giant Bar." This won a television set for his school and a candy bar for everyone in his class. 


*** How to prove Kleene's Theorem in 12.4

 - A set recognized by a finite-state automaton must be empty set, or the set contains only empty string, or {a} where a is a symbol in I, or AB or AUB or A* where A can be recognized by a finite-state automaton. 
 - the finite-state automata is M(S, I, f, S0, F)
 - the finite-state automata can be noted as all-none-final-states -> all-final-states -> all-none-final-states, which is kind of A*, where A is recognized by all-none-final-states -> all-final-states.
 - particularly, pick up all those states which are direct next states of final states, Sm, Sm->F is A*
 - All other states, So->Sm->F is BA*
