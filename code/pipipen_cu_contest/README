++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2.17更新：问题3思路
2.18更新：加入问题8答案
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
======================
=                    测试                    =
======================
解压后运行 make test 可以运行简单的测试

======================
=                    Q1                     =
======================
为了输入大数的时候不占用太多内存，采用了逐行计算的方式。

以输入为 4 为例，矩阵为
	1,	2,	3,	4
	12,	13,	14,	5
	11,	16,	15,	6
	10,	9,	8,	7

程序开始的时候先计算出了每圈左上角数字，占用 (N+1)/2 个整型位置。
	1,	_,	_,	_
	_,	13,	_,	_
	_,	_,	_,	_
	_,	_,	_,	_

第一行所有元素都属于最外圈，每个数字都可以根据最外圈起始数字 1 算出。
	1,	2,	3,	4

第二行根据他们离中心点的距离，可以计算出 [0] 和 [3] 属于最外圈，[1] 和 [2] 属于次外圈，每个数字又都可以根据起始数字算出。
	1,	2,	3,	4
	12,	13,	14,	5

以此类推，得到每一行的数字。最多只用分配了 (N+(N+1)/2) * 4 字节内存。

======================
=                    Q2                     =
======================
因为整体区间不大（1000001个数），因此用位图的方式解决这个问题 先调用 fill_range，把每个区间对应的位都置为 1。

然后从 0 位置寻找第一个连续闭区间，寻找的方法是先找到位图中从 0 位置开始第一个设为 1 的位，作为第一个连续闭区间的左值从左值的位置开始寻找第一个设为 0 的位，作为第一个连续闭区间的右值。

从上述闭区间的右值开始寻找下一个闭区间的左值，并类推寻找出所有连续闭区间。

后续工作:
find_set() 和 find_clear() 两个函数可以重构为一个函数。

======================
=                    Q3                     =
======================
struct line{
     struct line *next;
     char s[2048];
     int len;
     int serialno;
};

分 11 个 相应数据结构，10 个用于存放，， 1 个用于读下一行。先依次读入前十行，升序链接。读入下一行，如果不比链表第一个行长，直接放弃；否则，继续沿链表比下去，找到它应该在的位置，插入，把链表头上那个原来的第十长行的数据结构拿来作为下次读入的缓冲区。

优点：
1. 避免频繁分配释放内存，以及内存拷贝。
2. 减少比较次数。虽然最长行按升序排列，但没有用二分法等查找方式，因为默认输入行是随即长度的，所以越后面的行，进入前十行的概率越小，从第十长行往上比，效率也还可以。

======================
=                    Q8                     =
======================

用了投机取巧的方法，哈哈！用 strtok 直接取每个目录，不用条件编译也行，程序如下：

#include <string.h>
#include "contest.h"

int main()
{
    int retval = 0;
    char *env = NULL;
    char *individual = NULL;

    env = getenv(ENV_VAR);
    individual = strtok(env, DELIMINATER);

    while(individual != NULL)
    {
        printf("%s\n", individual);
        individual = strtok(NULL, DELIMINATER);
    }

    return retval;
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++