\documentclass[letter,11pt]{article}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{ulem}
\usepackage{amsmath}
\pagestyle{fancy}
\rhead{pengliu2}
\lhead{Peng Liu}
\author{Peng Liu, I2CS student}
\title{Homework 5\\CS411 2011 Spring}

\begin{document}
\lstset{language=SQL}
\maketitle

\section*{Problem 1: Query Execution}

\begin{enumerate}
\item[1.]

$B(R1) = 1140/15 = 76$

$M=15$

because $B(R1) + (B(R1) \times 28 /(M-1)) = 228$

$B(R2) = 28$ 

\item[2.]

$5B(R1)+5B(R2)=5\times76+5\times28=502$

\item[3.]

$3B(R1)+3B(R2)=3\times76+3\times28=312$

\item[4.]

$B(R1)+B(R2)=76+28=104$

\end{enumerate}

\section*{Problem 2: Cost Estimation}

\begin{enumerate}
\item[1.]

$T(R3.E)/V(R3.E) = 200/25 = 8$
    
\item[2.]
  
$T(R1.B) \times T(R3.F)/max(V(R1.C), V(R3.C)) = 500\times200/100 = 1000$
  
\item[3.]

$(T(R1.A) \times T(R2.D) / V(R1.A))/max(V(R1.B),V(R2.B) = (500\times5000/10)/400 = 625$

\end{enumerate}

\section*{Problem 3: Dynamic Programming}


\begin{tabular}{|l | l | l | l |}
  \hline
  Range of k            & Pipeline or Materialize & Algorithms for final join & Total disk I/O's\\
  \hline
  $k < 30$                & Pipeline                & one-pass                    & 27000\\
  \hline
  $30 <= k < 1500$        & Pipeline                & 30-bucket, two-pass         & 39000+2k\\
  \hline
  $1500 <= k < 2500$      & Materialize             & 50-bucket, two-pass         & 39000+4k\\
  \hline
  
\end{tabular}

\section*{Problem 4: Transaction Management}

\begin{enumerate}

\item[1.]

Atomicity means the sequence of actions succeeds or fails entirely.

Consistency means the resources are in consistent state before the transaction and after the transaction.

Isolation means transactions do not interfere with each other. They are aware of others when the others are done.

Durability means transactions make permanent changes once they are committed even if system failure happens.

The DBMS log file helps to ensure all of them on a system failure.

\item[2.]

Undo logging logs COMMIT before after OUTPUT is done, while redo logging does this before OUTPUT is done.

Undo logging logs the old values of the elements to be modified, while redo logging logs the future values.

So the undo logging is used to undo unfinished transactions and the logs are parsed from bottom to up to recover the DB. redo logging is to redo unfinished transactions and the logs are parsed from up to bottom to recover the DB.


\item[3.]

After line 17.

\end{enumerate}


\end{document}


